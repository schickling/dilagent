import type { SummaryInput } from '../schemas/file-management.ts'

export const createSummaryPrompt = (input: SummaryInput): string => {
  const { state, timeline, executionMetrics } = input

  // Convert hypotheses record to array for easier processing
  const hypothesesList = Object.values(state.hypotheses)
  const totalHypotheses = hypothesesList.length
  const completedHypotheses = hypothesesList.filter((h) => h.status === 'completed').length
  const successfulHypotheses = hypothesesList.filter((h) => h.result?._tag === 'Proven').length
  const failedHypotheses = hypothesesList.filter((h) => h.result?._tag === 'Disproven').length

  return `Generate a comprehensive markdown summary report for this Dilagent debugging session.

## Run Information
- **Context Directory**: ${state.contextDirectory}${state.contextRelativePath && state.contextRelativePath !== '.' ? ` (focusing on ${state.contextRelativePath} subdirectory)` : ''}
- **Working Directory**: ${state.workingDirectory}
- **Started**: ${new Date(state.metrics.startTime).toLocaleString()}
- **Current Phase**: ${state.currentPhase}
- **Total Duration**: ${Math.round(executionMetrics.wallClockTimeMs / 1000)}s

## Hypothesis Testing Results

**Summary**: ${totalHypotheses} hypotheses tested
- âœ… ${successfulHypotheses} successful
- âŒ ${failedHypotheses} failed
- â³ ${completedHypotheses}/${totalHypotheses} completed

### Hypothesis Details

${hypothesesList
  .map((h) => {
    const statusIcon =
      h.status === 'completed'
        ? h.result?._tag === 'Proven'
          ? 'âœ…'
          : h.result?._tag === 'Disproven'
            ? 'âŒ'
            : 'â”'
        : h.status === 'running'
          ? 'ðŸ”„'
          : 'â¸ï¸'

    const summary = h.result
      ? ` - ${h.result._tag === 'Proven' ? h.result.findings : h.result._tag === 'Disproven' ? h.result.reason : h.result.intractableReason}`
      : ''

    return `#### ${statusIcon} ${h.id}: ${h.slug}
- **Status**: ${h.status}${summary}
- **Worktree**: ${h.worktreePath}
${h.startedAt ? `- **Started**: ${h.startedAt}` : ''}
${h.completedAt ? `- **Completed**: ${h.completedAt}` : ''}`
  })
  .join('\n\n')}

## Key Timeline Events

${timeline.events
  .filter((event) => event.event.includes('phase.') || event.event.includes('hypothesis.') || event.phase !== undefined)
  .slice(-10) // Show last 10 key events
  .map(
    (event) =>
      `- **${event.timestamp}**: ${event.event}${event._tag === 'HypothesisEvent' && event.hypothesisId ? ` (${event.hypothesisId})` : ''}${event._tag !== 'UserEvent' && event._tag !== 'GitEvent' ? ` [${event.phase}]` : event.phase ? ` [${event.phase}]` : ''}`,
  )
  .join('\n')}

## Performance Metrics

- **Wall Clock Time**: ${Math.round(executionMetrics.wallClockTimeMs / 1000)}s
- **Total Events**: ${timeline.events.length}
- **Hypotheses Generated**: ${state.metrics.hypothesesGenerated}
- **Hypotheses Completed**: ${state.metrics.hypothesesCompleted}

## Next Steps

Based on the results from this debugging session, please provide:

1. **Root Cause Analysis**: What was definitively identified as the cause(s) of the issue?

2. **Recommended Actions**: What specific steps should be taken to resolve the problem?

3. **Prevention Strategies**: How can similar issues be avoided in the future?

4. **Remaining Investigations**: What questions remain unanswered and require further investigation?

---

*Generated by Dilagent v1.0 - Hypothesis-driven debugging for complex systems*`
}
